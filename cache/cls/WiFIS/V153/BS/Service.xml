<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="WiFIS.V153.BS.Service">
<Description>
Clase común de la que heredan todos los webservices de WiFIS.
Desde cada WebService en concreto se invoca al método Forward.
Modificaciones en clases generadas WSDL:
  WiFIS.V153.BS.s1.WSResposta: heredar de Ens.Response
  WiFIS.V153.BS.s1.WsMissatge: heredar de %SerialObject
</Description>
<IncludeCode>%occXSLT</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.SOAP.Service</Super>
<TimeCreated>62523,45402.31831</TimeCreated>
<LegacyInstanceContext>1</LegacyInstanceContext>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id$</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
This is the namespace used by the Service</Description>
<Default>http://tempuri.org/</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>1</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Description>
This is the name of the Service</Description>
<Default>WIFISHL7</Default>
</Parameter>

<Parameter name="SOAPVERSION">
<Description>
This is the SOAP version supported by the service.</Description>
<Default>1.1</Default>
</Parameter>

<Parameter name="USECLASSNAMESPACES">
<Description>
Namespaces of referenced classes will be used in the WSDL.</Description>
<Default>1</Default>
</Parameter>

<Parameter name="ADAPTER">
<Description>
The URL may be absolute or relative to the WSDL request URL..</Description>
</Parameter>

<Property name="ValidateSchema">
<Description>
Enable XML Schema Validation, using XML Schema Specified in XMLSchemaFile</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="XMLSchemaFile">
<Description>
Complete Path to XML Schema File to use for Valiation</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="WSDLFile">
<Description>
A File containing the WSDL to Return. This allows to override the WSDL generated by Ensemble
Solves the issue where the Ensembe WSDL does not use the correct namespace for the any input parameters</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="TargetConfigName">
<Description>
Target Business Host to Send the Message to</Description>
<Type>%String</Type>
</Property>

<Parameter name="SETTINGS">
<Description>
Can't do grace period without an OnTask loop</Description>
<Default><![CDATA[-AlertGracePeriod,ValidateSchema,XMLSchemaFile,WSDLFile,TargetConfigName:Basic:selector?context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId}]]></Default>
</Parameter>

<Method name="Forward">
<Description>
Implementa el mismo codigo para todos los WebMethods y todos los WebServices</Description>
<FormalSpec>pAny:%XML.String,pServiceName:%String,pMethodName:%String</FormalSpec>
<ReturnType>WiFIS.V153.BS.s1.WSResposta</ReturnType>
<Implementation><![CDATA[
	#dim tSC as %Status=$$$OK	
 	#dim errObj as %Exception.StatusException
 	#dim tRspMsg as WiFIS.V153.BS.s1.WSResposta
 	#dim tMsg as WiFIS.V153.Msg.GenericReq
 	#dim tCodi
 	#dim tFechaHoraIn=""
 	try {
	 	// fecha hora de entrada del mensaje
	 	set tFechaHoraIn=$zdt($h,3)  
	 	
		$$$TRACE("Service="_pServiceName_"; Method="_pMethodName)
	 	$$$TRACE("Content="_$get(pAny))
	 	
	 	// crear mensaje WiFIS Ensemble
 		set tMsg=##class(WiFIS.V153.Msg.GenericReq).%New()
 		do tMsg.DatosXML.Write(pAny)
 		set tMsg.Tipo=pMethodName
 		set tMsg.Servicio=pServiceName 
 		
 		// recuperar origen y destino directamente desde XML
 		do tMsg.DatosXML.Rewind()
 		$$$THROWONERROR(tSC,##class(%XML.XPATH.Document).CreateFromStream(tMsg.DatosXML,.tDoc))
 		set tDoc.PrefixMappings="hl7 urn:hl7-org:v2xml"
 		
 		// MSH.4 origen
 		$$$THROWONERROR(tSC,tDoc.EvaluateExpression("/hl7:*/hl7:MSH/hl7:MSH.4","hl7:HD.2/text()",.tResults))
 		if tResults.Count()>0 {
			set:tResults.GetAt(1).Type=$$$XPATHVALUE tMsg.Origen=tResults.GetAt(1).Value
		}
		
		// MSH.6 destino
		$$$THROWONERROR(tSC,tDoc.EvaluateExpression("/hl7:*/hl7:MSH/hl7:MSH.6","hl7:HD.2/text()",.tResults))
		if tResults.Count()>0 {
			set:tResults.GetAt(1).Type=$$$XPATHVALUE tMsg.Destino=tResults.GetAt(1).Value
		}
 		
 		// validar esquema si es necesario
 		if (..ValidateSchema) {
			#dim tFlags
			#dim tSchemaSpec
			set tFlags=$$$SAXVALIDATION + $$$SAXNAMESPACES + $$$SAXNAMESPACEPREFIXES + $$$SAXVALIDATIONSCHEMA //+ $$$SAXVALIDATIONSCHEMAFULLCHECKING
			
			set tSchemaSpec="urn:hl7-org:v2xml file:///"_..XMLSchemaFile		 
			$$$TRACE("Schema Validation tFlags="_tFlags_" tSchemaSpec="_tSchemaSpec)
			
		 	set tReader=##class(%XML.Reader).%New()
		 	set tReader.SAXFlags=tFlags
         	set tReader.SAXSchemaSpec=tSchemaSpec
 		
        	$$$THROWONERROR(tSC,tReader.OpenString(pAny)) 		
 		}
 		$$$THROWONERROR(tSC,..ProcessInput(tMsg,.tRspMsg))
 		
 		// recuperar el código de la respuesta (para estadísticas)
 		set tCodi="" 
 		if $isobject(tRspMsg) { 
 			if tRspMsg.LlistaMissatges.Size>0 {
 				set tCodi=tRspMsg.LlistaMissatges.GetAt(1).codi
 			}
 		}
 		
 		// guardar estadísticas WiFIS
 		do ##class(WiFIS.Stats.Messages).LogMsg("E",pServiceName,pMethodName,tMsg.Origen,tMsg.Destino,$g(tCodi),$get(tFechaHoraIn),$zdt($h,3))
 	} catch (errObj) {
		$$$TRACE("Error Forward")
	 	set tSC=errObj.AsStatus() 
 	}
 	
 	if '$isobject(tRspMsg) {
		$$$TRACE("no mensaje respuesta")
	 	// no hay mensaje de respuesta, construir uno y copiar el tSC dentro
	 	set tRspMsg=##class(WiFIS.V153.BS.s1.WSResposta).%New()
 	}
 	
 	if ($$$ISERR(tSC)) {
	 	// copiar informacion de error
	 	set tError=##class(WiFIS.V153.BS.s1.WSMissatge).%New()
	 	set tCodi=+$SYSTEM.Status.GetErrorCodes(tSC)
	 	set tError.codi=$SELECT(tCodi=10001:"WIFIS_DEST_UNK",tCodi=10002:"WIFIS_SRC_UNK",tCodi=10003:"WIFIS_TIMEOUT",tCodi=10004:"WIFIS_INVALID",1:"WIFIS_INVALID")  //10002 & 1 was WFIS_ERROR_PLATAFORMA
		if ($g(%tMsg)="") { 	
	 		set tError.descripcio=$SYSTEM.Status.GetOneErrorText(tSC)
		}else {
			set tError.descripcio=%tMsg
		}
	 	do tRspMsg.LlistaMissatges.Insert(tError)
	 	$$$TRACE("Error.code="_tError.codi_"; Error.descripcion="_tError.descripcio)
	 	
	 	set tCodi=tError.descripcio
 		do ##class(WiFIS.Stats.Messages).LogMsg("E",pServiceName,pMethodName,tMsg.Origen,tMsg.Destino,$g(tCodi),$get(tFechaHoraIn),$zdt($h,3))
 	}
 	
	quit tRspMsg
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<Description>
Enviar el mensaje WiFIS Ensemble al componente configurado en TargetConfigName</Description>
<FormalSpec><![CDATA[pInput:WiFIS.V153.Msg.GenericReq,*pOutput:WiFIS.V153.BS.s1.WSResposta,&pHint:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		$$$THROWONERROR(tSC,..SendRequestSync(..TargetConfigName,pInput,.pOutput,120))
	} catch (errObj) {
		set tSC=errObj.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
This user callback method is called just after %OnNew()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ret = $$$OK
	try {
		if ((..ValidateSchema=1) && (..XMLSchemaFile="")) {
			$$$LOGWARNING("XMLSchemaFile required when ValidateSchema=true")
		}
		
		if (""=..TargetConfigName) { $$$LOGWARNING("No TargetConfigName configured") }
		
		/*
		if ##class(ITB.Info).#VERSION < ##class(WiFIS.Info).#ITBMINVERSION {
			$$$LOGWARNING("ITB version does not meet WiFIS ITB required minimum version")
		}
		*/
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<Description>
Return an array of connections for drawing lines on the config diagram</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	do pItem.PopulateModifiedSettings()
	Set (tValue,tIndex)="" For {
		Set tSetting = pItem.ModifiedSettings.GetNext(.tIndex) Quit:tIndex=""
		If tSetting.Name="TargetConfigName" Set tValue=tSetting.Value  Quit
	}
	Set pArray(tValue)=""
]]></Implementation>
</Method>

<Method name="OnPage">
<Description>
Override it to be able to return an abitrary WSDL if needed</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If $Data(%request.Data("WSDL"))!$Data(%request.Data("wsdl")) {
		#; If it's a WSDL Request, just generate the WSDL for the client
		#dim tSvc
		#dim tSC as %Status
		set tSC=##class(Ens.Director).CreateBusinessService(..%ClassName(1),.tSvc)
		if ($$$ISOK(tSC)) {
			if (tSvc.WSDLFile="") {
				// implementación original
				quit ##class(%XML.Implementation).GenerateWSDL(..%ClassName(1))
			} else {
				set tFile=##class(%Stream.FileBinary).%New()
				set tFile.Filename=tSvc.WSDLFile
				while (tFile.AtEnd=0) {
					write tFile.Read()
				}
				
			}		
		} else {
			quit ##class(%XML.Implementation).GenerateWSDL(..%ClassName(1))
		}
	} else {
		do ##super()
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
