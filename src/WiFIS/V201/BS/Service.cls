Include %occXSLT

/// Clase común de la que heredan todos los webservices de WiFIS.
/// Desde cada WebService en concreto se invoca al método Forward.
/// Modificaciones en clases generadas WSDL:
///   WiFIS.V201.BS.s1.WSResposta: heredar de Ens.Response
///   WiFIS.V201.BS.s1.WsMissatge: heredar de %SerialObject
/// 
Class WiFIS.V201.BS.Service Extends EnsLib.SOAP.Service [ LegacyInstanceContext, ProcedureBlock ]
{

/// Location and Revision of this file in Perforce (Auto-updating)
Parameter SrcVer = "$Id: //custom_ccrs/_common/tools/Iberia/WiFIS/latest/cls/WiFIS/V201/BS/Service.xml#2 $";

/// This is the namespace used by the Service
Parameter NAMESPACE = "http://tempuri.org/";

/// Use xsi:type attribute for literal types.
Parameter OUTPUTTYPEATTRIBUTE = 1;

/// This is the name of the Service
Parameter SERVICENAME = "WIFISHL7";

/// This is the SOAP version supported by the service.
Parameter SOAPVERSION = 1.1;

/// Namespaces of referenced classes will be used in the WSDL.
Parameter USECLASSNAMESPACES = 1;

/// The URL may be absolute or relative to the WSDL request URL..
Parameter ADAPTER;

/// Enable XML Schema Validation, using XML Schema Specified in XMLSchemaFile
Property ValidateSchema As %Boolean [ InitialExpression = 0 ];

/// Complete Path to XML Schema File to use for Valiation
Property XMLSchemaFile As %String(MAXLEN = 255);

/// A File containing the WSDL to Return. This allows to override the WSDL generated by Ensemble
/// Solves the issue where the Ensembe WSDL does not use the correct namespace for the any input parameters
Property WSDLFile As %String(MAXLEN = 255);

/// Target Business Host to Send the Message to
Property TargetConfigName As %String;

/// Conversión de caracteres que se aplicará al mensaje de entrada (vacío para no aplicar ninguna).
Property Charset As %String(MAXLEN = 50) [ InitialExpression = "UTF8" ];

/// Devolver SOAP Fault si se produce un error al recibir el mensaje WiFIS
Property ReturnSOAPFault As %Boolean [ InitialExpression = 0 ];

/// Can't do grace period without an OnTask loop
Parameter SETTINGS = "Charset:WiFIS,ReturnSOAPFault:WiFIS,-AlertGracePeriod,ValidateSchema,XMLSchemaFile,WSDLFile,TargetConfigName:Basic:selector?context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId}";

/// Implementa el mismo codigo para todos los WebMethods y todos los WebServices
Method Forward(pAny As %XML.GlobalCharacterStream, pServiceName As %String, pMethodName As %String) As WiFIS.V201.BS.s1.WSResposta
{
	#dim tSC as %Status=$$$OK	
 	#dim errObj as %Exception.StatusException
 	#dim tRspMsg as WiFIS.V201.BS.s1.WSResposta
 	#dim tMsg as WiFIS.V201.Msg.GenericReq
 	#dim tCodi
 	#dim tFechaHoraIn=""
 	set tRspMsg=""
 	try {
	 	// fecha hora de entrada del mensaje
	 	set tFechaHoraIn=$zdt($h,3)  
	 	
		$$$TRACE("Service="_pServiceName_"; Method="_pMethodName)
	 	$$$TRACE("Content="_$get(pAny))
	 	
	 	// crear mensaje WiFIS Ensemble
 		set tMsg=##class(WiFIS.V201.Msg.GenericReq).%New()
 		
 		// convertir la cadena XML recibida en el webservice
 		set converted = ##class(%XML.GlobalCharacterStream).%New()
 		if ..Charset="UTF8" {
			while 'pAny.AtEnd {
				do converted.Write($zconvert(pAny.Read(), "O", "UTF8"))
			}
 		}
 		do tMsg.DatosXML.CopyFrom(converted)

 		// método y servicio WiFIS
 		set tMsg.Tipo=pMethodName
 		set tMsg.Servicio=pServiceName 
 		
 		// recuperar origen y destino directamente desde XML
 		do tMsg.DatosXML.Rewind()
 		$$$THROWONERROR(tSC,##class(%XML.XPATH.Document).CreateFromStream(tMsg.DatosXML,.tDoc))
 		set tDoc.PrefixMappings="hl7 urn:hl7-org:v2xml"
 		
 		// MSH.4 origen
 		$$$THROWONERROR(tSC,tDoc.EvaluateExpression("/hl7:*/hl7:MSH/hl7:MSH.4","hl7:HD.1/text()",.tResults))
 		if tResults.Count()>0 {
			set:tResults.GetAt(1).Type=$$$XPATHVALUE tMsg.Origen=tResults.GetAt(1).Value
		}
		
		// MSH.6 destino
		$$$THROWONERROR(tSC,tDoc.EvaluateExpression("/hl7:*/hl7:MSH/hl7:MSH.6","hl7:HD.1/text()",.tResults))
		if tResults.Count()>0 {
			set:tResults.GetAt(1).Type=$$$XPATHVALUE tMsg.Destino=tResults.GetAt(1).Value
		}
 		
 		// validar esquema si es necesario
 		if (..ValidateSchema) {
			#dim tFlags
			#dim tSchemaSpec
			set tFlags=$$$SAXVALIDATION + $$$SAXNAMESPACES + $$$SAXNAMESPACEPREFIXES + $$$SAXVALIDATIONSCHEMA //+ $$$SAXVALIDATIONSCHEMAFULLCHECKING
			
			set tSchemaSpec="urn:hl7-org:v2xml file:///"_..XMLSchemaFile		 
			$$$TRACE("Schema Validation tFlags="_tFlags_" tSchemaSpec="_tSchemaSpec)
			
		 	set tReader=##class(%XML.Reader).%New()
		 	set tReader.SAXFlags=tFlags
         	set tReader.SAXSchemaSpec=tSchemaSpec
 		
        	$$$THROWONERROR(tSC,tReader.OpenString(pAny)) 		
 		}
 		$$$THROWONERROR(tSC,..ProcessInput(tMsg,.tRspMsg))
 		
 		// recuperar el código de la respuesta (para estadísticas)
 		set tCodi="" 
 		if $isobject(tRspMsg) { 
 			if tRspMsg.LlistaMissatges.Size>0 {
 				set tCodi=tRspMsg.LlistaMissatges.GetAt(1).codi
 			}
 		}
 		
 		// guardar estadísticas WiFIS
 		do ##class(WiFIS.Stats.Messages).LogMsg("E",pServiceName,pMethodName,tMsg.Origen,tMsg.Destino,$g(tCodi),$get(tFechaHoraIn),$zdt($h,3))
 	} catch (errObj) {
		$$$TRACE("Error Forward")
	 	set tSC=errObj.AsStatus() 
 	}
 	
 	if '$isobject(tRspMsg) {
		$$$TRACE("no mensaje respuesta")
	 	// no hay mensaje de respuesta, construir uno y copiar el tSC dentro
	 	set tRspMsg=##class(WiFIS.V201.BS.s1.WSResposta).%New()
 	}
 	
 	if ($$$ISERR(tSC)) {
	 	// copiar informacion de error
	 	set tError=##class(WiFIS.V201.BS.s1.WSMissatge).%New()
	 	set tCodi=+$SYSTEM.Status.GetErrorCodes(tSC)
	 	
	 	set tError.codi=$select(tCodi=10001:"WIFIS_DEST_UNK",tCodi=10002:"WIFIS_SRC_UNK",tCodi=10003:"WIFIS_TIMEOUT",tCodi=10004:"WIFIS_INVALID",1:"WIFIS_INVALID")  //10002 & 1 was WFIS_ERROR_PLATAFORMA
		if ($get(%tMsg)="") { 	
	 		set tError.descripcio=$SYSTEM.Status.GetErrorText(tSC)
		} else {
			set tError.descripcio=%tMsg
		}
		
		// log de eventos
	 	$$$LOGERROR("Error.code="_tError.codi_"; Error.descripcion="_tError.descripcio)
		
		// mensaje respuesta con error wifis
	 	do tRspMsg.LlistaMissatges.Insert(tError)
	 	
	 	// registrar error en estadísticas wifis
	 	set tCodi=tError.descripcio
 		do ##class(WiFIS.Stats.Messages).LogMsg("E",pServiceName,pMethodName,tMsg.Origen,tMsg.Destino,$g(tCodi),$get(tFechaHoraIn),$zdt($h,3))
 		
 		// registro error y alertas
 		if ..ReturnSOAPFault {
	 		// devolver SOAP Fault. servicio marcará error y enviará alerta si está configurado.
	 		do ..ReturnStatusFault($$$FAULTClient, tSC)
 		} 
 		else {
	 		// marcar servicio en estado de error
	 		$$$SetHostMonitor(..%ConfigName,$$$eMonitorStatus,"Error")
	 		// no devuelve Fault, pero se envía alerta si está configurado.	
	 		if ..AlertOnError do ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))
 		}
 	}
 	
	quit tRspMsg
}

/// Enviar el mensaje WiFIS Ensemble al componente configurado en TargetConfigName
Method OnProcessInput(pInput As WiFIS.V201.Msg.GenericReq, Output pOutput As WiFIS.V201.BS.s1.WSResposta, ByRef pHint As %String) As %Status
{
	try {
		$$$THROWONERROR(tSC,..SendRequestSync(..TargetConfigName,pInput,.pOutput,120))
	} catch (errObj) {
		set tSC=errObj.AsStatus()
	}
	quit tSC
}

/// This user callback method is called just after %OnNew()
Method OnInit() As %Status
{
	set ret = $$$OK
	try {
		if ((..ValidateSchema=1) && (..XMLSchemaFile="")) {
			$$$LOGWARNING("XMLSchemaFile required when ValidateSchema=true")
		}
		
		if (""=..TargetConfigName) { $$$LOGWARNING("No TargetConfigName configured") }
		
		/*
		if ##class(ITB.Info).#VERSION < ##class(WiFIS.Info).#ITBMINVERSION {
			$$$LOGWARNING("ITB version does not meet WiFIS ITB required minimum version")
		}
		*/
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

/// Return an array of connections for drawing lines on the config diagram
ClassMethod OnGetConnections(Output pArray As %String, pItem As Ens.Config.Item)
{
	do pItem.PopulateModifiedSettings()
	Set (tValue,tIndex)="" For {
		Set tSetting = pItem.ModifiedSettings.GetNext(.tIndex) Quit:tIndex=""
		If tSetting.Name="TargetConfigName" Set tValue=tSetting.Value  Quit
	}
	Set pArray(tValue)=""
}

/// Override it to be able to return an abitrary WSDL if needed
ClassMethod OnPage() As %Status [ Internal, ServerOnly = 1 ]
{
	If $Data(%request.Data("WSDL"))!$Data(%request.Data("wsdl")) {
		#; If it's a WSDL Request, just generate the WSDL for the client
		#dim tSvc
		#dim tSC as %Status
		set tSC = ##class(Ens.Director).CreateBusinessService(..%ClassName(1),.tSvc)
		if ($$$ISOK(tSC)) {
			if (tSvc.WSDLFile="") {
				quit ..GenerateStandardWDSL()
			} else {
				set tFile=##class(%Stream.FileBinary).%New()
				set tFile.Filename=tSvc.WSDLFile
				while (tFile.AtEnd=0) {
					write tFile.Read()
				}
			}		
		} else {
			quit ..GenerateStandardWDSL()
		}
	} else {
		do ##super()
	}
	quit $$$OK
}

/// Genera documento WSDL estándar para el Business Service
ClassMethod GenerateStandardWDSL() As %Status
{
	set ret = $$$OK
	try {
		if $system.Version.GetMajor() <= 2014 {
			$$$ThrowOnError(##class(%XML.Implementation).GenerateWSDL(..%ClassName(1)))
		} else {
			// segundo parámetro necesario a partir de 2015
			$$$ThrowOnError(##class(%XML.Implementation).GenerateWSDL(..%ClassName(1), 1))
		}
	} catch ex {
		set ret = ex.AsStatus()
	}
	quit ret
}

}
